

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService  = game:GetService("UserInputService")
local TweenService      = game:GetService("TweenService")

local LocalPlayer       = Players.LocalPlayer
local Character         = LocalPlayer.Character
--local RootPart          = Character:WaitForChild("HumanoidRootPart")
--local Humanoid          = Character:WaitForChild("Humanoid")


--local Mouse             = LocalPlayer:GetMouse()

--local TouchHandler      = ReplicatedStorage.Events.__DFfDD
local UserInputService  = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PlayerService     = game:GetService("Players")
local RunService        = game:GetService("RunService")
--local StarterGui        = game:GetService("StarterGui")

local LocalPlayer = PlayerService.LocalPlayer
local Backpack    = LocalPlayer.Backpack
local Character   = LocalPlayer.Character

--local CharStats       = ReplicatedStorage.CharStats:FindFirstChild(LocalPlayer.Name)
--local FalldamageEvent = ReplicatedStorage.Events.__DFfDD

local Camera          = workspace.CurrentCamera

local is_key_down     = UserInputService.IsKeyDown

local library = {}
repeat task.wait() until game:IsLoaded()

local playerService = game:GetService("Players")
local tweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = playerService.LocalPlayer

local function GenerateRandomName()
	local Table = {}

	for i = 1, math.random(8, 19) do
		Table[i] = string.char(math.random(96, 122))
	end

	return table.concat(Table)
end

function library:InitUI(keybind)
	local screenGui = Instance.new("ScreenGui", player.PlayerGui)
	screenGui.Name = GenerateRandomName()
	screenGui.ResetOnSpawn = false
	screenGui.DisplayOrder = math.huge - 1
	
	local holder = Instance.new("Frame", screenGui)
	holder.Name = GenerateRandomName()
	holder.BackgroundColor3 = Color3.fromRGB(27,27,29)
	holder.BackgroundTransparency = 0.135
	holder.Position = UDim2.new(0.075, 0, 0.133, 0)
	holder.Size = UDim2.new(0, 482, 0, 515)
	holder.Draggable = true
	holder.Active = true
	holder.BorderSizePixel = 0
	
	local holderUC = Instance.new("UICorner", holder)
	holderUC.Name = GenerateRandomName()
	holderUC.CornerRadius = UDim.new(0, 7)
	
	local holderUS = Instance.new("UIStroke", holder)
	holderUS.Name = GenerateRandomName()
	holderUS.Color = Color3.fromRGB(31, 31, 31)
	holderUS.Transparency = 0.6
	
	local holderBar = Instance.new("Frame", holder)
	holderBar.Name = GenerateRandomName()
	holderBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	holderBar.Position = UDim2.new(0, 0, -0.005, 0)
	holderBar.Size = UDim2.new(1, 0, 0, 20)
	holderBar.BorderSizePixel = 0
	
	local holderBarUC = Instance.new("UICorner", holderBar)
	holderBarUC.Name = GenerateRandomName()
	holderBarUC.CornerRadius = UDim.new(0, 7)
	
	local holderBarO = Instance.new("Frame", holderBar)
	holderBarO.Name = GenerateRandomName()
	holderBarO.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	holderBarO.Position = UDim2.new(0, 0, 0.545, 0)
	holderBarO.Size = UDim2.new(1, 0, 0, 12)
	holderBarO.BorderSizePixel = 0
	
	local holderBarT = Instance.new("TextLabel", holderBar)
	holderBarT.Name = GenerateRandomName()
	holderBarT.BackgroundTransparency = 1
	holderBarT.Position = UDim2.new(0.017, 0, 0.15, 0)
	holderBarT.Size = UDim2.new(0, 135, 0, 19)
	holderBarT.ZIndex = 2
	holderBarT.Font = Enum.Font.Gotham
	holderBarT.Text = "Kinetic Lite - The best private cheat provider since 2020"
	holderBarT.TextColor3 = Color3.fromRGB(255, 255, 255)
	holderBarT.TextSize = 11
	holderBarT.TextXAlignment = Enum.TextXAlignment.Left
	
	local holderLine = Instance.new("Frame", holder)
	holderLine.Name = GenerateRandomName()
	holderLine.BackgroundColor3 = Color3.fromRGB(33,33,34)
	holderLine.Position = UDim2.new(0.017, 0, 0.112, 0)
	holderLine.Size = UDim2.new(0, 467, 0, 1)
	holderLine.BorderSizePixel = 0
	holderLine.ZIndex = 2
	
	local holderKey = Instance.new("TextLabel", holder)
	holderKey.Name = GenerateRandomName()
	holderKey.BackgroundTransparency = 1
	holderKey.Position = UDim2.new(0.70, 0, 0.936, 0)
	holderKey.Size = UDim2.new(0, 126, 0, 33)
	holderKey.ZIndex = 2
	holderKey.Font = Enum.Font.SourceSans
	holderKey.Text = "Menu toggle keybind: " .. keybind.Name
	holderKey.TextColor3 = Color3.fromRGB(156, 156, 156)
	holderKey.TextSize = 14
	
	local saveOldPosition, absolutePosition = 0, 0
	local tickOld = tick()
	
	UserInputService.InputBegan:Connect(function(input, _1)
		if _1 then return end
		
		if input.KeyCode == keybind and tick() - tickOld > 0.55 then
			if holder.Visible == true then
				saveOldPosition, absolutePosition = holder.Position, holder.AbsolutePosition
				task.wait()
				tweenService:Create(holder, TweenInfo.new(0.4), {Position = UDim2.new(2, 0, 0, holder.AbsolutePosition.Y)}):Play()
				task.delay(0.4, function()
					holder.Visible = false
				end)
			elseif holder.Visible == false then
				holder.Visible = true
				holder.Position = UDim2.new(-2, 0, 0, absolutePosition.Y)
				tweenService:Create(holder, TweenInfo.new(0.4), {Position = saveOldPosition}):Play()
			end
			tickOld = tick()
		end
	end)
	
	local guiInstances = {Objects = {}, CurrentTab = nil, Count = 0}
	
	function guiInstances:CreateTab(name)
		guiInstances.Count += 1
		
		local holderTab = Instance.new("Frame", holder)
		holderTab.Name = GenerateRandomName()
		holderTab.BackgroundColor3 = Color3.fromRGB(12, 12, 15)
		holderTab.Position = UDim2.new(0.036, 0, 0.075, 0)
		holderTab.Size = UDim2.new(0, 52, 0, 20)
		holderTab.BorderSizePixel = 0
		
		local holderTabUC = Instance.new("UICorner", holderTab)
		holderTabUC.Name = GenerateRandomName()
		holderTabUC.CornerRadius = UDim.new(0, 7)
		
		local holderTabO = Instance.new("Frame", holderTab)
		holderTabO.Name = GenerateRandomName()
		holderTabO.BackgroundColor3 = Color3.fromRGB(12, 12, 15)
		holderTabO.Position = UDim2.new(0, 0, 0.545, 0)
		holderTabO.Size = UDim2.new(1, 0, 0, 9)
		holderTabO.BorderSizePixel = 0
		
		local holderTabT = Instance.new("TextLabel", holderTab)
		holderTabT.Name = GenerateRandomName()
		holderTabT.BackgroundTransparency = 1
		holderTabT.Position = UDim2.new(0, 0, 0.15, 0)
		holderTabT.Size = UDim2.new(1, 0, 0, 17)
		holderTabT.ZIndex = 2
		holderTabT.Font = Enum.Font.GothamMedium
		holderTabT.Text = name
		holderTabT.TextColor3 = Color3.fromRGB(255, 255, 255)
		holderTabT.TextSize = 11
		
		local holderTabB = Instance.new("TextButton", holderTab)
		holderTabB.Name = GenerateRandomName()
		holderTabB.AutoButtonColor = false
		holderTabB.BackgroundTransparency = 1
		holderTabB.Size = UDim2.new(1, 0, 1, 0)
		holderTabB.Text = ""
		holderTabB.ZIndex = 2
		
		local holderSF = Instance.new("ScrollingFrame", holder)
		holderSF.Name = GenerateRandomName()
		holderSF.BackgroundTransparency = 1
		holderSF.Position = UDim2.new(0.036, 0, 0.144, 0)
		holderSF.Size = UDim2.new(0, 464, 0, 440)
		holderSF.ScrollBarThickness = 0
		holderSF.BorderSizePixel = 0

		--[[local holderSFLL = Instance.new("UIListLayout", holderSF)
		holderSFLL.Name = GenerateRandomName()
		holderSFLL.FillDirection = Enum.FillDirection.Vertical
		holderSFLL.HorizontalAlignment = Enum.HorizontalAlignment.Left
		holderSFLL.VerticalAlignment = Enum.VerticalAlignment.Top
		holderSFLL.Padding = UDim.new(0, 9)--]]
		
		local getNextPosition = 0
		for i,v in pairs(guiInstances.Objects) do if string.find(tostring(i), "Tab") then getNextPosition += v.Title.TextBounds.X + 36 end end

		holderTab.Size = UDim2.new(0, holderTabT.TextBounds.X + 31, 0, 20)
		holderTab.Position = UDim2.new(0.036, getNextPosition, 0.075, 0)
		
		guiInstances.Objects[name.."Tab"] = {
			Tab = holderTab,
			UICorner = holderTabUC,
			Overlay = holderTabO,
			Title = holderTabT,
			Button = holderTabB,
			MainFrame = holderSF,
			--MainFrameUIListLayout = holderSFLL,
			SizeInPixels = 0,
			SkippingFirst = true,
		}
		
		holderSF.Visible = false
		
		if guiInstances.Count == 1 then
			guiInstances.CurrentTab = holderTabT.Text
			tweenService:Create(holderTab, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(43, 43, 41)}):Play()
			tweenService:Create(holderTabO, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(43, 43, 41)}):Play()
			task.wait(0.075)
			holderSF.Visible = true
		end
		
		holderTabB.MouseButton1Down:Connect(function()
			if guiInstances.CurrentTab ~= holderTabT.Text then
				tweenService:Create(holderTab, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(43, 43, 41)}):Play()
				tweenService:Create(holderTabO, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(43, 43, 41)}):Play()
				
				tweenService:Create(guiInstances.Objects[guiInstances.CurrentTab .."Tab"].Tab, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(12, 12, 15)}):Play()
				tweenService:Create(guiInstances.Objects[guiInstances.CurrentTab .."Tab"].Overlay, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(12, 12, 15)}):Play()
				guiInstances.Objects[guiInstances.CurrentTab .."Tab"].MainFrame.Visible = false
				
				task.wait(0.075)
				holderSF.Visible = true
				
				guiInstances.CurrentTab = holderTabT.Text
			end
		end)
		
		local function CalculateNewSize()
			--local studs = guiInstances.Objects[name .."Tab"].SizeInPixels
			
			--if studs > holderSF.AbsoluteSize.Y then studs = holderSF.AbsoluteSize.Y + 25 end
			holderSF.CanvasSize = UDim2.new(0, 0, 0, guiInstances.Objects[name .."Tab"].SizeInPixels + 35)
		end
		
		CalculateNewSize(holderSF)
		
		local cheat = {}
		
		function cheat:Checkbox(Properties)
			guiInstances.Count += 1
			
			if guiInstances.Objects[name .."Tab"].SkippingFirst == false then
				guiInstances.Objects[name .."Tab"].SizeInPixels += 24 + 9
			end
			
			if guiInstances.Objects[name .."Tab"].SizeInPixels == 0 and guiInstances.Objects[name .."Tab"].SkippingFirst == true then
				guiInstances.Objects[name .."Tab"].SkippingFirst = false
			end

			local title = Properties.Title or "Checkbox"
			local callback = Properties.Callback or function(val) end
			
			local checkboxB = Instance.new("TextButton", holderSF)
			checkboxB.Name = GenerateRandomName()
			checkboxB.AutoButtonColor = false
			checkboxB.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			checkboxB.BackgroundTransparency = 0.4
			checkboxB.Size = UDim2.new(0, 24, 0, 24)
			checkboxB.Position = UDim2.new(0, 0, 0, guiInstances.Objects[name.."Tab"].SizeInPixels)
			checkboxB.Text = ""
			checkboxB.ZIndex = 2
			
			local checkboxUC = Instance.new("UICorner", checkboxB)
			checkboxUC.Name = GenerateRandomName()
			checkboxUC.CornerRadius = UDim.new(0, 3)
			
			local check = Instance.new("ImageLabel", checkboxB)
			check.BackgroundTransparency = 1
			check.Position = UDim2.new(0, 0, 0, 0)
			check.Size = UDim2.new(0, 24, 0, 24)
			check.ZIndex = 2
			check.Image = "rbxassetid://10796491103"
			check.ImageTransparency = 1
			
			local checkTitle = Instance.new("TextLabel", checkboxB)
			checkTitle.Name = GenerateRandomName()
			checkTitle.BackgroundTransparency = 1
			checkTitle.Position = UDim2.new(1.392, 0, 0.15, 0)
			checkTitle.Size = UDim2.new(0, 102, 0, 19)
			checkTitle.ZIndex = 1
			checkTitle.Font = Enum.Font.Gotham
			checkTitle.Text = title
			checkTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
			checkTitle.TextSize = 12
			checkTitle.TextXAlignment = Enum.TextXAlignment.Left
			
			guiInstances.Objects[title .."CheckBox"] = {
				Checkbox = checkboxB,
				UICorner = checkboxUC,
				ImageLabel = check,
				Title = checkTitle,
				Enabled = false
			}
			
			checkboxB.MouseButton1Down:Connect(function()
				guiInstances.Objects[title .."CheckBox"].Enabled = not guiInstances.Objects[title .."CheckBox"].Enabled
				
				if guiInstances.Objects[title .."CheckBox"].Enabled then
					tweenService:Create(check, TweenInfo.new(0.1), {ImageTransparency = 0}):Play()
				else
					tweenService:Create(check, TweenInfo.new(0.1), {ImageTransparency = 1}):Play()
				end
				
				if callback then callback(guiInstances.Objects[title .."CheckBox"].Enabled) end
			end)
			
			CalculateNewSize(holderSF)
		end
		
		function cheat:Text(text)
			guiInstances.Count += 1
			
			if guiInstances.Objects[name .."Tab"].SkippingFirst == false then
				guiInstances.Objects[name .."Tab"].SizeInPixels += 25 + 9
			end
			
			if guiInstances.Objects[name .."Tab"].SizeInPixels == 0 and guiInstances.Objects[name .."Tab"].SkippingFirst == true then
				guiInstances.Objects[name .."Tab"].SkippingFirst = false
			end
			
			local checkTitle = Instance.new("TextLabel", holderSF)
			checkTitle.Name = GenerateRandomName()
			checkTitle.BackgroundTransparency = 1
			checkTitle.Size = UDim2.new(0, 102, 0, 19)
			checkTitle.Position = UDim2.new(0, 0, 0, guiInstances.Objects[name.."Tab"].SizeInPixels)
			checkTitle.ZIndex = 1
			checkTitle.Font = Enum.Font.Gotham
			checkTitle.Text = text
			checkTitle.TextColor3 = Color3.fromRGB(156, 156, 156)
			checkTitle.TextSize = 12
			checkTitle.TextXAlignment = Enum.TextXAlignment.Left
			
			guiInstances.Objects[name .."Text"] =  {
				Title = checkTitle
			}
			
			CalculateNewSize(holderSF)
		end
		
		function cheat:Slider(Properties)
			guiInstances.Count += 1
			
			if guiInstances.Objects[name .."Tab"].SkippingFirst == false then
				guiInstances.Objects[name .."Tab"].SizeInPixels += 24 + 9
			end
			
			if guiInstances.Objects[name .."Tab"].SizeInPixels == 0 and guiInstances.Objects[name .."Tab"].SkippingFirst == true then
				guiInstances.Objects[name .."Tab"].SkippingFirst = false
			end
			
			local title = Properties.Title or "Slider"
			local type = Properties.Type or "Int"
			local min = Properties.Min or 0
			local max = Properties.Max or 100
			local callback = Properties.Callback or function(val) end
			
			local sliderBackground = Instance.new("Frame", holderSF)
			sliderBackground.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			sliderBackground.BackgroundTransparency = 0.4
			sliderBackground.Size = UDim2.new(0, 280, 0, 24)
			sliderBackground.Position = UDim2.new(0, 0, 0, guiInstances.Objects[name.."Tab"].SizeInPixels)
			
			local sliderBackgroundUC = Instance.new("UICorner", sliderBackground)
			sliderBackgroundUC.Name = GenerateRandomName()
			sliderBackgroundUC.CornerRadius = UDim.new(0, 5)
			
			local slider = Instance.new("Frame", sliderBackground)
			slider.BackgroundColor3 = Color3.fromRGB(81, 81, 81)
			slider.BackgroundTransparency = 0.35
			slider.Position = UDim2.new(0, 2, 0.08, 0)
			slider.Size = UDim2.new(0, 10, 0, 20)
			
			local sliderUC = Instance.new("UICorner", slider)
			sliderUC.Name = GenerateRandomName()
			sliderUC.CornerRadius = UDim.new(0, 3)
			
			local sliderValue = Instance.new("TextLabel", sliderBackground)
			sliderValue.Name = GenerateRandomName()
			sliderValue.BackgroundTransparency = 1
			sliderValue.Position = UDim2.new(0, 0, 0.1, 0)
			sliderValue.Size = UDim2.new(1, 0, 0, 19)
			sliderValue.ZIndex = 2
			sliderValue.Font = Enum.Font.Gotham
			sliderValue.TextColor3 = Color3.fromRGB(255, 255, 255)
			sliderValue.TextSize = 12
			
			local sliderTitle = Instance.new("TextLabel", sliderBackground)
			sliderTitle.Name = GenerateRandomName()
			sliderTitle.BackgroundTransparency = 1
			sliderTitle.Position = UDim2.new(1.044, 0, 0.063, 0)
			sliderTitle.Size = UDim2.new(0, 102, 0, 19)
			sliderTitle.ZIndex = 2
			sliderTitle.Font = Enum.Font.Gotham
			sliderTitle.Text = title
			sliderTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
			sliderTitle.TextSize = 12
			sliderTitle.TextXAlignment = Enum.TextXAlignment.Left
			
			guiInstances.Objects[title .."Slider"] = {
				SliderBackground = sliderBackground,
				SliderBackgroundUICorner = sliderBackgroundUC,
				Slider = slider,
				SliderUICorner = sliderUC,
				SliderValue = sliderValue,
				SliderTitle = sliderTitle,
				Draggable = false,
				CurrentValue = 0
			}
			
			callback = callback or function(val) end
			
			if min >= 0 then
				local value = math.clamp((min / max) * (max - min) + min or 0, min, max)
				
				if type == "Int" then
					value = math.round(value)
				elseif type == "Float" then
					value = tonumber(string.format("%.2f", value))
				end
				
				sliderValue.Text = value
				
				guiInstances.Objects[title .."Slider"].CurrentValue = value
				if callback then callback(value) end
			end

			local function slide(input)
				local size = math.clamp(input.Position.X + 1 - sliderBackground.AbsolutePosition.X - 5, 0, 266)
				local percent = size / 266
				
				slider.Position = UDim2.new(0, size + 2, 0.08, 0)
				
				local value = math.clamp(math.round((min + (max - min) * percent) * 100) / 100, min, max)
				
				if type == "Int" then
					value = math.round(value)
				elseif type == "Float" then
					value = tonumber(string.format("%.2f", value))
				end
				
				sliderValue.Text = value
				
				guiInstances.Objects[title .."Slider"].CurrentValue = value
				
				if callback then callback(value) end
			end
			
			slider.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slide(input)
					holder.Draggable = false
					guiInstances.Objects[title .."Slider"].Draggable = true
				end
			end)

			slider.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					holder.Draggable = true
					guiInstances.Objects[title .."Slider"].Draggable = false
				end
			end)

			sliderBackground.InputChanged:Connect(function(input)
				if guiInstances.Objects[title .."Slider"].Draggable and input.UserInputType == Enum.UserInputType.MouseMovement then
					slide(input)
				end
			end)
			
			CalculateNewSize(holderSF)
		end
		
		function cheat:Button(Properties)
			guiInstances.Count += 1

			if guiInstances.Objects[name .."Tab"].SkippingFirst == false then
				guiInstances.Objects[name .."Tab"].SizeInPixels += 24 + 9
			end

			if guiInstances.Objects[name .."Tab"].SizeInPixels == 0 and guiInstances.Objects[name .."Tab"].SkippingFirst == true then
				guiInstances.Objects[name .."Tab"].SkippingFirst = false
			end

			local title = Properties.Title or "Button"
			local callback = Properties.Callback or function() end
			
			local button = Instance.new("TextButton", holderSF)
			button.Name = GenerateRandomName()
			button.AutoButtonColor = false
			button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			button.BackgroundTransparency = 0.4
			button.Size = UDim2.new(0, 160, 0, 24)
			button.Position = UDim2.new(0, 0, 0, guiInstances.Objects[name.."Tab"].SizeInPixels)
			button.Text = title
			button.ZIndex = 2
			
			local buttonUC = Instance.new("UICorner", button)
			buttonUC.Name = GenerateRandomName()
			buttonUC.CornerRadius = UDim.new(0, 7)
			
			local buttonTitle = Instance.new("TextLabel", button)
			buttonTitle.Name = GenerateRandomName()
			buttonTitle.BackgroundTransparency = 1
			buttonTitle.Position = UDim2.new(0.18, 0, 0.1, 0)
			buttonTitle.Size = UDim2.new(0, 102, 0, 19)
			buttonTitle.ZIndex = 2
			buttonTitle.Font = Enum.Font.Gotham
			buttonTitle.Text = title
			buttonTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
			buttonTitle.TextSize = 12
			
			guiInstances.Objects[title .."Button"] = {
				Button = button,
				ButtonUICorner = buttonUC,
				ButtonTitle = buttonTitle
			}
			
			button.MouseButton1Down:Connect(function()
				if callback then callback() end
			end)
			
			CalculateNewSize(holderSF)
		end
		
		function cheat:Keybind(Properties)
			guiInstances.Count += 1
			
			local titleCheckbox = Properties.Checkbox.Title or "Checkbox"
			local titleKeybind = Properties.Title or "Keybind"
			local default = Properties.Default or Enum.KeyCode.E
			local callbackKeybind = Properties.Callback or function() end
			local callbackCheckbox = Properties.Checkbox.Callback or function() end
			
			if guiInstances.Objects[name .."Tab"].SkippingFirst == false then
				guiInstances.Objects[name .."Tab"].SizeInPixels += 24 + 9
			end

			if guiInstances.Objects[name .."Tab"].SizeInPixels == 0 and guiInstances.Objects[name .."Tab"].SkippingFirst == true then
				guiInstances.Objects[name .."Tab"].SkippingFirst = false
			end
			
			local checkboxB = Instance.new("TextButton", holderSF)
			checkboxB.Name = GenerateRandomName()
			checkboxB.AutoButtonColor = false
			checkboxB.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			checkboxB.BackgroundTransparency = 0.4
			checkboxB.Size = UDim2.new(0, 24, 0, 24)
			checkboxB.Position = UDim2.new(0, 0, 0, guiInstances.Objects[name.."Tab"].SizeInPixels)
			checkboxB.Text = ""
			checkboxB.ZIndex = 2

			local checkboxUC = Instance.new("UICorner", checkboxB)
			checkboxUC.Name = GenerateRandomName()
			checkboxUC.CornerRadius = UDim.new(0, 3)

			local check = Instance.new("ImageLabel", checkboxB)
			check.BackgroundTransparency = 1
			check.Position = UDim2.new(0, 0, 0, 0)
			check.Size = UDim2.new(0, 24, 0, 24)
			check.ZIndex = 2
			check.Image = "rbxassetid://10796491103"
			check.ImageTransparency = 1

			local checkTitle = Instance.new("TextLabel", checkboxB)
			checkTitle.Name = GenerateRandomName()
			checkTitle.BackgroundTransparency = 1
			checkTitle.Position = UDim2.new(1.392, 0, 0.15, 0)
			checkTitle.Size = UDim2.new(0, 102, 0, 19)
			checkTitle.ZIndex = 1
			checkTitle.Font = Enum.Font.Gotham
			checkTitle.Text = titleCheckbox
			checkTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
			checkTitle.TextSize = 12
			checkTitle.TextXAlignment = Enum.TextXAlignment.Left
			
			
			local curKey
			curKey = curKey or default
			
			
			local keybindB = Instance.new("TextButton", checkboxB)
			keybindB.Name = GenerateRandomName()
			keybindB.AutoButtonColor = false
			keybindB.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			keybindB.BackgroundTransparency = 0.4
			keybindB.Size = UDim2.new(0, 20, 0, 24)
			keybindB.Position = UDim2.new(0, 24 + checkTitle.TextBounds.X + 22, 0, 0)
			keybindB.Text = ""
			keybindB.ZIndex = 2

			local keybindUC = Instance.new("UICorner", keybindB)
			keybindUC.Name = GenerateRandomName()
			keybindUC.CornerRadius = UDim.new(0, 3)
			
			local keybindKeyTitle = Instance.new("TextLabel", keybindB)
			keybindKeyTitle.Name = GenerateRandomName()
			keybindKeyTitle.BackgroundTransparency = 1
			keybindKeyTitle.Position = UDim2.new(0, 2, 0.042, 0)
			keybindKeyTitle.Size = UDim2.new(0, 17, 0, 24)
			keybindKeyTitle.ZIndex = 2
			keybindKeyTitle.Font = Enum.Font.Gotham
			keybindKeyTitle.Text = curKey.Name
			keybindKeyTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
			keybindKeyTitle.TextSize = 12
			
			guiInstances.Objects[titleKeybind .."Keybind"] = {
				Checkbox = {
					Checkbox = checkboxB,
					UICorner = checkboxUC,
					ImageLabel = check,
					Title = checkTitle,
					Enabled = false
				},
				Keybind = keybindB,
				KeybindUICorner = keybindUC,
				KeyTitle = keybindKeyTitle,
				CurrentKey = curKey,
				KeyPressChange = false
			}
			
			checkboxB.MouseButton1Down:Connect(function()
				guiInstances.Objects[titleKeybind .."Keybind"].Checkbox.Enabled = not guiInstances.Objects[titleKeybind .."Keybind"].Checkbox.Enabled

				if guiInstances.Objects[titleKeybind .."Keybind"].Checkbox.Enabled then
					tweenService:Create(check, TweenInfo.new(0.1), {ImageTransparency = 0}):Play()
				else
					tweenService:Create(check, TweenInfo.new(0.1), {ImageTransparency = 1}):Play()
				end
				
				if callbackCheckbox then callbackCheckbox(guiInstances.Objects[titleKeybind .."Keybind"].Checkbox.Enabled) end
			end)
			
			local banned = {
				"Return",
				"Space",
				"Tab",
				"Unknown"
			}
			
			UserInputService.InputBegan:Connect(function(input, _1)
				if _1 then return end
				if not guiInstances.Objects[titleKeybind .."Keybind"].Checkbox.Enabled then return end

				if guiInstances.Objects[titleKeybind .."Keybind"].KeyPressChange == false and curKey and input.KeyCode == curKey and keybindKeyTitle.Text ~= "..." then
					if callbackKeybind then callbackKeybind(input.KeyCode) end
				end
			end)
			
			keybindB.MouseButton1Down:Connect(function()
				if guiInstances.Objects[titleKeybind .."Keybind"].Checkbox.Enabled then
					guiInstances.Objects[titleKeybind .."Keybind"].KeyPressChange = true
					keybindKeyTitle.Text = "..."
					
					task.delay(5, function()
						keybindKeyTitle.Text = curKey.Name
						guiInstances.Objects[titleKeybind .."Keybind"].KeyPressChange = false
					end)
					
					while keybindKeyTitle.Text == "..." do
						local input = UserInputService.InputBegan:Wait()
						
						if not table.find(banned, input.KeyCode.Name) then
							curKey = input.KeyCode

							keybindKeyTitle.Text = tostring(curKey.Name)
						end
						
						task.wait()
					end
					
					guiInstances.Objects[titleKeybind .."Keybind"].KeyPressChange = false
				end
				task.wait(0.1)
			end)
			
			CalculateNewSize()
		end
		
		return cheat
	end
	
	return guiInstances
end








getgenv().Settings = {
    Radius       = 0;
    FOVEnabled   = false;
    TargetPart   = 'Head';
    Enabled      = false;
    VisibleCheck = false;
    MaxParts     = 1;
}

local Camera        = workspace.CurrentCamera
local Players       = game:GetService("Players")
local RunService    = game:GetService("RunService")

local LocalPlayer   = Players.LocalPlayer
local Mouse         = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local WorldToScreen = Camera.WorldToScreenPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild

local script_name do
    for i,v in pairs(getgc(true)) do
        if type(v) == "table" and rawget(v, "OnRayUpdated") and rawget(v, "VisualizeBullet") and rawget(v, "updtCam") then
            script_name = rawget(getinfo(v.OnRayUpdated).short_src:split("."), 4)
            break
        end
    end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character

    if not (PlayerCharacter or LocalPlayerCharacter) then return end

    local PlayerRoot = FindFirstChild(PlayerCharacter, Settings.melTargetPart) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")

    if not PlayerRoot then return end

    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)

    return ObscuringObjects <= Settings.MaxParts
end

local function getClosestPlayer()
    local Closest
    local DistanceToMouse
    for _, Player in next, GetChildren(Players) do
        if Player == LocalPlayer then continue end

        local Character = Player.Character
        if not Character then continue end

        if Settings.VisibleCheck and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart  = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid          = FindFirstChild(Character, "Humanoid")
        local Head              = FindFirstChild(Character, "Head")

        if not HumanoidRootPart or not Humanoid or not Head or Humanoid and Humanoid.Health <= 0 then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)

        if not OnScreen then continue end

        local Distance = (Vector2.new(Mouse.X, Mouse.Y) - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or (Settings.FOVEnabled and Settings.Radius) or 2000) then
            Closest = Character[Settings.TargetPart]
            DistanceToMouse = Distance
        end
    end

    return Closest
end

local fov_circle = Drawing.new("Circle") do
    fov_circle.Thickness = 0.5
    fov_circle.NumSides = 100
    fov_circle.Radius = Settings.Radius
    fov_circle.Filled = false
    fov_circle.Visible = false
    fov_circle.ZIndex = 999
    fov_circle.Transparency = 999
    fov_circle.Color = Color3.fromRGB(255,255,255)

    coroutine.resume(coroutine.create(function()
        RunService.RenderStepped:Connect(function()
            fov_circle.Visible = Settings.FOVEnabled
            if fov_circle.Visible then
                fov_circle.Radius   = Settings.Radius
                fov_circle.Position = Vector2.new(Mouse.X, Mouse.Y) + Vector2.new(0, 36)
            end
        end)
    end))
end

local raycastArguments = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(...)
    local Method    = getnamecallmethod()
    local Caller    = tostring(getcallingscript())
    local Arguments = {...}
    local self      = Arguments[1]

    if Settings.Enabled and Method == "Raycast" and self == workspace and Caller == script_name then
        if ValidateArguments(Arguments, raycastArguments) then
            local A_Origin = Arguments[2]

            local HitPart = getClosestPlayer()
            if HitPart then
                Arguments[3] = getDirection(A_Origin, HitPart.Position)

                return oldNamecall(unpack(Arguments))
            end
        end
    end
    return oldNamecall(...)
end)






function Notify(msg)
	local l__ReplicatedStorage__1 = game:GetService("ReplicatedStorage");
	l__ReplicatedStorage__1.Events2.Notification:Fire({
		Title = 'Kinetic Lite',
		Text = tostring(msg),
		Duration = 5
	}, "lost");
	end




local ESP = loadstring(game:HttpGet("https://kiriot22.com/releases/ESP.lua"))()
        ESP:Toggle(true)
        ESP.Players = false 
        ESP.Tracers = false 
        ESP.Boxes = false 
        ESP.Names = false
        ESP.Color = Color3.fromRGB(255,255,255)
        ESP.Thickness = 0.5

		  -- Med safes --
		  for i,v in pairs(game:GetService("Workspace").Map.BredMakurz:GetDescendants()) do
            if string.find(v.Name,"MediumSafe") then 
                if v:FindFirstChild("MainPart") then 
                    ESP:Add(v.MainPart, {
                        Name = "Medium Safe",
                        IsEnabled = "mediumSafe",
                        Color = Color3.fromRGB(255,255,255)
                    })
                end 
            end 
        end
        
        -- Small safes --
        for i,v in pairs(game:GetService("Workspace").Map.BredMakurz:GetDescendants()) do
            if string.find(v.Name,"SmallSafe") then 
                if v:FindFirstChild("MainPart") then 
                    ESP:Add(v.MainPart, {
                        Name = "Small Safe",
                        IsEnabled = "smallSafe",
                        Color = Color3.fromRGB(255,255,255)
                    })
                end 
            end 
        end
        
        -- Registers --
        for i,v in pairs(game:GetService("Workspace").Map.BredMakurz:GetDescendants()) do
            if string.find(v.Name,"Register") then 
                if v:FindFirstChild("MainPart") then 
                    ESP:Add(v.MainPart, {
                        Name = "Register",
                        IsEnabled = "registerSafe",
                        Color = Color3.fromRGB(255,255,255)
                    })
                end 
            end 
        end



        


        -- Dealers
        for i,v in pairs(game:GetService("Workspace").Map.Shopz:GetDescendants()) do
            if string.find(v.Name,"Dealer") then 
                if v:FindFirstChild("MainPart") then 
                    ESP:Add(v.MainPart, {
                        Name = "Dealer",
                        IsEnabled = "dealerStore",
                        Color = Color3.fromRGB(255,255,255)
                    })
                end 
            end 
        end
        
             -- ATMs --
             for i,v in pairs(game:GetService("Workspace").Map.ATMz:GetDescendants()) do
                if string.find(v.Name,"ATM") then 
                    if v:FindFirstChild("MainPart") then 
                        ESP:Add(v.MainPart, {
                            Name = "ATM",
                            IsEnabled = "atmPart",
                            Color = Color3.fromRGB(255,255,255)
                        })
                    end 
                end 
            end
            
        
        -- Scraps
        ESP:AddObjectListener(game:GetService("Workspace").Filter.SpawnedPiles, {
            Type = "Model",
            CustomName = "Scrap",
            Color = Color3.fromRGB(255,255,255),
            IsEnabled = "scrapPart"
        })




local Settings2 = {


NoRecoil = false,
InfiniteStamina = false,
FieldOfView_Enabled = false,
    FieldOfViewValue = 0,
	fullBright = false, 
	InstantAim = false,
	NoFallDamage = false,
	NoRagdoll = false, 
    
}

game.Players.LocalPlayer.Character.ChildAdded:Connect(function(Item)
	if Item:IsA("Tool") then
			for i,v in pairs(getgc(true)) do 
				if type(v) == 'table' and rawget(v, 'AimSpeed') then 
					if Settings2.InstantAim == true then
							
							v.AimSpeed = 0.04
						  end
					end
				end
			end
	end)










local mt = getrawmetatable(game)
local oIndex = mt.__index
local oNIndex = mt.__newindex

setreadonly(mt,false)

mt.__newindex = newcclosure(function(tab,key,val)
	if(Settings2.fullBright and tab==game.Lighting and key=="Ambient")then
		val = Color3.new(fartvalue,fartvalue,fartvalue)
	end
	
	return oNIndex(tab,key,val)    
end)

make_writeable(mt)

		 
game:GetService("RunService").RenderStepped:Connect(function()
	if Settings2.FieldOfView_Enabled == true then
		game:GetService("ReplicatedStorage").CharStats[game.Players.LocalPlayer.Name].FOVs:WaitForChild("Value").Value = Settings2.FieldOfViewValue
	else
		game:GetService("ReplicatedStorage").CharStats[game.Players.LocalPlayer.Name].FOVs:WaitForChild("Value").Value = 0
	end
end)



local oldSpawn
oldSpawn =
    hookfunction(
    getrenv().spawn,
    function(...)
        if (Settings2.NoRecoil and not checkcaller() and debug.getinfo(({...})[1], "n").name == "lioceRCamera") then
            return
        end
    return oldSpawn(...)
end
)






local lib = library:InitUI(Enum.KeyCode.End)
local tab1 = lib:CreateTab("Visuals")
local tab2 = lib:CreateTab("Character")
local tab3 = lib:CreateTab('Weapon')
local tab4 = lib:CreateTab("Misc")
--local tab5 = lib:CreateTab("Teleports")




local text01 = tab1:Text("Player Visuals")

 tab1:Checkbox({
	Title = "Esp",
	Callback = function(value)


		ESP:Toggle(value)
		ESP.Players = value 
	end;
})


 tab1:Checkbox({
	Title    = "Names";
	
	Callback = function(value)
		ESP.Names = value
 end;
})
 tab1:Checkbox({
	Title    = "Box";

	Callback = function(value)
	  ESP.Boxes = value
	end;
})

tab1:Checkbox({
	Title    = 'Tracers';

	Callback = function(value)
	  ESP.Tracers = value
	end;
})

tab1:Checkbox({
	Title    = "Skeleton";

	Callback = function(value)
	  if value == true then
		local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local Camera = game:GetService("Workspace").CurrentCamera

local function DrawLine()
    local l = Drawing.new("Line")
    l.Visible = false
    l.From = Vector2.new(0, 0)
    l.To = Vector2.new(1, 1)
    l.Color = Color3.fromRGB(255, 255, 255)
    l.Thickness = 1
    l.Transparency = 1
    return l
end

local function DrawESP(plr)
    repeat wait() until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil
    local limbs = {}
    local R15 = (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15) and true or false
    if R15 then 
        limbs = {
            -- Spine
            Head_UpperTorso = DrawLine(),
            UpperTorso_LowerTorso = DrawLine(),
            -- Left Arm
            UpperTorso_LeftUpperArm = DrawLine(),
            LeftUpperArm_LeftLowerArm = DrawLine(),
            LeftLowerArm_LeftHand = DrawLine(),
            -- Right Arm
            UpperTorso_RightUpperArm = DrawLine(),
            RightUpperArm_RightLowerArm = DrawLine(),
            RightLowerArm_RightHand = DrawLine(),
            -- Left Leg
            LowerTorso_LeftUpperLeg = DrawLine(),
            LeftUpperLeg_LeftLowerLeg = DrawLine(),
            LeftLowerLeg_LeftFoot = DrawLine(),
            -- Right Leg
            LowerTorso_RightUpperLeg = DrawLine(),
            RightUpperLeg_RightLowerLeg = DrawLine(),
            RightLowerLeg_RightFoot = DrawLine(),
        }
    else 
        limbs = {
            Head_Spine = DrawLine(),
            Spine = DrawLine(),
            LeftArm = DrawLine(),
            LeftArm_UpperTorso = DrawLine(),
            RightArm = DrawLine(),
            RightArm_UpperTorso = DrawLine(),
            LeftLeg = DrawLine(),
            LeftLeg_LowerTorso = DrawLine(),
            RightLeg = DrawLine(),
            RightLeg_LowerTorso = DrawLine()
        }
    end
    local function Visibility(state)
        for i, v in pairs(limbs) do
            v.Visible = state
        end
    end

    local function Colorize(color)
        for i, v in pairs(limbs) do
            v.Color = color
        end
    end

    local function UpdaterR15()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    -- Head
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                    if limbs.Head_UpperTorso.From ~= Vector2.new(H.X, H.Y) then
                        --Spine
                        local UT = Camera:WorldToViewportPoint(plr.Character.UpperTorso.Position)
                        local LT = Camera:WorldToViewportPoint(plr.Character.LowerTorso.Position)
                        -- Left Arm
                        local LUA = Camera:WorldToViewportPoint(plr.Character.LeftUpperArm.Position)
                        local LLA = Camera:WorldToViewportPoint(plr.Character.LeftLowerArm.Position)
                        local LH = Camera:WorldToViewportPoint(plr.Character.LeftHand.Position)
                        -- Right Arm
                        local RUA = Camera:WorldToViewportPoint(plr.Character.RightUpperArm.Position)
                        local RLA = Camera:WorldToViewportPoint(plr.Character.RightLowerArm.Position)
                        local RH = Camera:WorldToViewportPoint(plr.Character.RightHand.Position)
                        -- Left leg
                        local LUL = Camera:WorldToViewportPoint(plr.Character.LeftUpperLeg.Position)
                        local LLL = Camera:WorldToViewportPoint(plr.Character.LeftLowerLeg.Position)
                        local LF = Camera:WorldToViewportPoint(plr.Character.LeftFoot.Position)
                        -- Right leg
                        local RUL = Camera:WorldToViewportPoint(plr.Character.RightUpperLeg.Position)
                        local RLL = Camera:WorldToViewportPoint(plr.Character.RightLowerLeg.Position)
                        local RF = Camera:WorldToViewportPoint(plr.Character.RightFoot.Position)

                        --Head
                        limbs.Head_UpperTorso.From = Vector2.new(H.X, H.Y)
                        limbs.Head_UpperTorso.To = Vector2.new(UT.X, UT.Y)

                        --Spine
                        limbs.UpperTorso_LowerTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_LowerTorso.To = Vector2.new(LT.X, LT.Y)

                        -- Left Arm
                        limbs.UpperTorso_LeftUpperArm.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_LeftUpperArm.To = Vector2.new(LUA.X, LUA.Y)

                        limbs.LeftUpperArm_LeftLowerArm.From = Vector2.new(LUA.X, LUA.Y)
                        limbs.LeftUpperArm_LeftLowerArm.To = Vector2.new(LLA.X, LLA.Y)

                        limbs.LeftLowerArm_LeftHand.From = Vector2.new(LLA.X, LLA.Y)
                        limbs.LeftLowerArm_LeftHand.To = Vector2.new(LH.X, LH.Y)

                        -- Right Arm
                        limbs.UpperTorso_RightUpperArm.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_RightUpperArm.To = Vector2.new(RUA.X, RUA.Y)

                        limbs.RightUpperArm_RightLowerArm.From = Vector2.new(RUA.X, RUA.Y)
                        limbs.RightUpperArm_RightLowerArm.To = Vector2.new(RLA.X, RLA.Y)

                        limbs.RightLowerArm_RightHand.From = Vector2.new(RLA.X, RLA.Y)
                        limbs.RightLowerArm_RightHand.To = Vector2.new(RH.X, RH.Y)

                        -- Left Leg
                        limbs.LowerTorso_LeftUpperLeg.From = Vector2.new(LT.X, LT.Y)
                        limbs.LowerTorso_LeftUpperLeg.To = Vector2.new(LUL.X, LUL.Y)

                        limbs.LeftUpperLeg_LeftLowerLeg.From = Vector2.new(LUL.X, LUL.Y)
                        limbs.LeftUpperLeg_LeftLowerLeg.To = Vector2.new(LLL.X, LLL.Y)

                        limbs.LeftLowerLeg_LeftFoot.From = Vector2.new(LLL.X, LLL.Y)
                        limbs.LeftLowerLeg_LeftFoot.To = Vector2.new(LF.X, LF.Y)

                        -- Right Leg
                        limbs.LowerTorso_RightUpperLeg.From = Vector2.new(LT.X, LT.Y)
                        limbs.LowerTorso_RightUpperLeg.To = Vector2.new(RUL.X, RUL.Y)

                        limbs.RightUpperLeg_RightLowerLeg.From = Vector2.new(RUL.X, RUL.Y)
                        limbs.RightUpperLeg_RightLowerLeg.To = Vector2.new(RLL.X, RLL.Y)

                        limbs.RightLowerLeg_RightFoot.From = Vector2.new(RLL.X, RLL.Y)
                        limbs.RightLowerLeg_RightFoot.To = Vector2.new(RF.X, RF.Y)
                    end

                    if limbs.Head_UpperTorso.Visible ~= true then
                        Visibility(true)
                    end
                else 
                    if limbs.Head_UpperTorso.Visible ~= false then
                        Visibility(false)
                    end
                end
            else 
                if limbs.Head_UpperTorso.Visible ~= false then
                    Visibility(false)
                end
                if game.Players:FindFirstChild(plr.Name) == nil then 
                    for i, v in pairs(limbs) do
                        v:Remove()
                    end
                    connection:Disconnect()
                end
            end
        end)
    end

    local function UpdaterR6()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                    if limbs.Head_Spine.From ~= Vector2.new(H.X, H.Y) then
                        local T_Height = plr.Character.Torso.Size.Y/2 - 0.2
                        local UT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, T_Height, 0)).p)
                        local LT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, -T_Height, 0)).p)

                        local LA_Height = plr.Character["Left Arm"].Size.Y/2 - 0.2
                        local LUA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, LA_Height, 0)).p)
                        local LLA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, -LA_Height, 0)).p)

                        local RA_Height = plr.Character["Right Arm"].Size.Y/2 - 0.2
                        local RUA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, RA_Height, 0)).p)
                        local RLA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, -RA_Height, 0)).p)

                        local LL_Height = plr.Character["Left Leg"].Size.Y/2 - 0.2
                        local LUL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, LL_Height, 0)).p)
                        local LLL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, -LL_Height, 0)).p)

                        local RL_Height = plr.Character["Right Leg"].Size.Y/2 - 0.2
                        local RUL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, RL_Height, 0)).p)
                        local RLL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, -RL_Height, 0)).p)

                        -- Head
                        limbs.Head_Spine.From = Vector2.new(H.X, H.Y)
                        limbs.Head_Spine.To = Vector2.new(UT.X, UT.Y)

                        --Spine
                        limbs.Spine.From = Vector2.new(UT.X, UT.Y)
                        limbs.Spine.To = Vector2.new(LT.X, LT.Y)

                        --Left Arm
                        limbs.LeftArm.From = Vector2.new(LUA.X, LUA.Y)
                        limbs.LeftArm.To = Vector2.new(LLA.X, LLA.Y)

                        limbs.LeftArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.LeftArm_UpperTorso.To = Vector2.new(LUA.X, LUA.Y)

                        --Right Arm
                        limbs.RightArm.From = Vector2.new(RUA.X, RUA.Y)
                        limbs.RightArm.To = Vector2.new(RLA.X, RLA.Y)

                        limbs.RightArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.RightArm_UpperTorso.To = Vector2.new(RUA.X, RUA.Y)

                        --Left Leg
                        limbs.LeftLeg.From = Vector2.new(LUL.X, LUL.Y)
                        limbs.LeftLeg.To = Vector2.new(LLL.X, LLL.Y)

                        limbs.LeftLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                        limbs.LeftLeg_LowerTorso.To = Vector2.new(LUL.X, LUL.Y)

                        --Right Leg
                        limbs.RightLeg.From = Vector2.new(RUL.X, RUL.Y)
                        limbs.RightLeg.To = Vector2.new(RLL.X, RLL.Y)

                        limbs.RightLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                        limbs.RightLeg_LowerTorso.To = Vector2.new(RUL.X, RUL.Y)
                    end

                    if limbs.Head_Spine.Visible ~= true then
                        Visibility(true)
                    end
                else 
                    if limbs.Head_Spine.Visible ~= false then
                        Visibility(false)
                    end
                end
            else 
                if limbs.Head_Spine.Visible ~= false then
                    Visibility(false)
                end
                if game.Players:FindFirstChild(plr.Name) == nil then 
                    for i, v in pairs(limbs) do
                        v:Remove()
                    end
                    connection:Disconnect()
                end
            end
        end)
    end

    if R15 then
        coroutine.wrap(UpdaterR15)()
    else 
        coroutine.wrap(UpdaterR6)()
    end
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= Player.Name then
        DrawESP(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= Player.Name then
        DrawESP(newplr)
    end
end)
	  
	  elseif value == false then
print('S0:203')
	  end

	end;
})


tab1:Text("Farming Visuals")
tab1:Checkbox({
	Title    = "Include Safes";

	Callback = function(value)
		ESP.mediumSafe = value 
		ESP.smallSafe = value 

	end;
})

tab1:Checkbox({
	Title    = "Include Registers";

	Callback = function(value)

ESP.registerSafe = value 
end;
})
tab1:Checkbox({
	Title    = "Include Scraps";

	Callback = function(value)

	--ESP.scrapPart = value 
	ESP.ScrapESP = value
end;
})



 tab1:Checkbox({
	Title    = "Include Dealers";

	Callback = function(value)

ESP.dealerStore = value 
end;
})


tab1:Text("Viewmodel Visuals")


tab1:Checkbox({
    Title    = "FOV Modifier";
        Callback = function(value)
    
            Settings2.FieldOfView_Enabled = value
        end;
    })

	
    
    tab1:Slider({
        Title = "Stretch Multiplier",
        Min = 0,
        Max = 50,
        Callback = function(value)
    
            Settings2.FieldOfViewValue = value
        end;
    })

tab1:Checkbox({
	Title    = "Hide Arm Viewmodel";

	Callback = function(value)
if value == true then
	game:GetService("Workspace").Camera.ViewModel["Right Arm"].Size = Vector3.new(0,0,0)
	game:GetService("Workspace").Camera.ViewModel["Left Arm"].Size = Vector3.new(0,0,0)
elseif value == false then
	game:GetService("Workspace").Camera.ViewModel["Right Arm"].Size = Vector3.new(1.2,1.2,1.2)
	game:GetService("Workspace").Camera.ViewModel["Left Arm"].Size = Vector3.new(1.2,1.2,1.2)
end

end;
}) 

    
    
    tab1:Text('World')
    
tab1:Checkbox({
	Title    = "Modify Brightness";

	Callback = function(value)

		Settings2.fullBright = value
	end;
})



tab1:Slider({
    Title = "Brightness Multiplier",
    Min = 0,
    Max = 1,
    Callback = function(value)

		fartvalue = value
	end;
})



 tab1:Button({
Title    = "No Atmosphere";
	
	Callback = function()
		game:GetService("Lighting").Atmosphere:Destroy()
end;
})
tab1:Button({
Title    = "No Sky";

Callback = function()

game:GetService("Lighting")["Clouded Sky"]:Destroy()
end;
})
    

	  


tab2:Checkbox({
	Title = "Infinite Stamina",
	Callback = function(value)
		Settings2.InfiniteStamina = value
	end,
})





tab2:Checkbox({
	Title    = "Disable Fall Damage";

	Callback = function(value)

		Settings2.NoFallDamage = value
	end;
})
tab2:Checkbox({
	Title    = "Disable Ragdolling";

	Callback = function(value)

		Settings2.AntiRagdoll = value
	end;
})





tab2:Checkbox({
	Title    = "Disable Camera Shake";

	Callback = function(value)
		if value == true then
			for i,v in pairs(getgc(true)) do
				if type(v) == 'table' and rawget(v, 'CameraBobbing') then
					rawset(v, 'CameraBobbing', false)
				end
			end
		elseif value == false then
			for i,v in pairs(getgc(true)) do
				if type(v) == 'table' and rawget(v, 'CameraBobbing') then
					rawset(v, 'CameraBobbing', true)
				end
			end
		end

end;
})
















tab3:Text("Aiming")
tab3:Checkbox({
	Title = "Aim Assist",
	Callback = function(value)
		Settings.Enabled = value
	end,
})



tab3:Slider({
    Title = "Aim Assist FOV",
    Min = 0,
    Max = 85,
    Callback = function(value)
        Settings.Radius = value
    end,
})
--tab3:Text('Aim Assist automatically targets the h')
tab3:Text("Target Parts")
tab3:Checkbox({
	Title = "Target: Head",
	Callback = function(value)
		if value == true then
			Notify('Currently Assisting At : Head')
		Settings.TargetPart = 'Head'

		elseif value == false then
			Notify('Currently Assisting At : Torso')
			Settings.TargetPart = 'HumanoidRootPart'

		end
	end,
})
tab3:Checkbox({
	Title = "Target: Torso",
	Callback = function(value)
		if value == true then
			Notify('Currently Assisting At : Torso')
		Settings.TargetPart = 'HumanoidRootPart'

		elseif value == false then
			Notify('Currently Assisting At : Head')
			Settings.TargetPart = 'Head'

		end
	end,
})
tab3:Text('Weapon Modifications')

tab3:Checkbox({
	Title = "No Recoil",
	Callback = function(value)
		Settings2.NoRecoil = value
	end,
})



tab3:Checkbox({
	Title = "No Spread",
	Callback = function(value)
	
	end,
})


tab3:Checkbox({
	Title    = "Instant Aim";
	Callback = function(value)
	
	Settings2.InstantAim = value 
	end;
	})

	tab3:Checkbox({
		Title    = 'No Firing Animations';
		Callback = function(value)
		if value == true then
	
			local Character   = game.Players.LocalPlayer.Character
			local Backpack    = game.Players.LocalPlayer.Backpack
			local RootPart    = Character.HumanoidRootPart
			local Weapon      = Character:FindFirstChildOfClass("Tool") or Backpack:FindFirstChildOfClass("Tool")
			
			local BackupConfs = {}
			
			function UpdateWeaponStats(Weapon, ChangeFunc)
				if Weapon.Parent == Character then
					Weapon.Parent = Backpack
				end
				
				Weapon.Client.Disabled = true
				ChangeFunc(require(Weapon.Config))
				Weapon.Client.Disabled = false
				
				local SelfCA 
				SelfCA = Weapon.ChildAdded:Connect(function(NewChild)
					if NewChild.Name == "GunClient" then 
						Weapon.Parent = Character
						SelfCA:Disconnect()
					end
				end)
			end
			
			
			UpdateWeaponStats(Weapon, function(Config)
				--// Creating Backup Config
				if not BackupConfs[Config] then 
					BackupConfs[Config] = Config
				end
				
				local BackupConfig = BackupConfs[Config]
			
				--// Changing & Backuping Configs
				local FireModeSettings = Config.FireModeSettings
				
				Config.FireAnimWeight = math.huge
				Config.FireAnimSpeed = math.huge
				Config.FlashSettings.Enabled =  false
			end)
	
		elseif value == false then
			local Character   = game.Players.LocalPlayer.Character
			local Backpack    = game.Players.LocalPlayer.Backpack
			local RootPart    = Character.HumanoidRootPart
			local Weapon      = Character:FindFirstChildOfClass("Tool") or Backpack:FindFirstChildOfClass("Tool")
			
			local BackupConfs = {}
			
			function UpdateWeaponStats(Weapon, ChangeFunc)
				if Weapon.Parent == Character then
					Weapon.Parent = Backpack
				end
				
				Weapon.Client.Disabled = true
				ChangeFunc(require(Weapon.Config))
				Weapon.Client.Disabled = false
				
				local SelfCA 
				SelfCA = Weapon.ChildAdded:Connect(function(NewChild)
					if NewChild.Name == "GunClient" then 
						Weapon.Parent = Character
						SelfCA:Disconnect()
					end
				end)
			end
			
			
			UpdateWeaponStats(Weapon, function(Config)
				--// Creating Backup Config
				if not BackupConfs[Config] then 
					BackupConfs[Config] = Config
				end
				
				local BackupConfig = BackupConfs[Config]
			
				--// Changing & Backuping Configs
				local FireModeSettings = Config.FireModeSettings
				
				Config.FireAnimWeight = 0.75
				Config.FireAnimSpeed = 1.35
	
			end)
		end
		end;
	})




tab4:Text('Farming')
tab4:Checkbox({
	Title    = "No Fail Lockpick";
	Callback = function(value)

end;
})

tab4:Checkbox({
	Title    = "Instant Interact";
	Callback = function(value)

end;
})


tab4:Text('User Safety')
tab4:Checkbox({
	Title    = "Administrator Notifier";
	Callback = function(value)

end;
})
tab4:Checkbox({
	Title    = "Contributor Notifier";
	Callback = function(value)

end;
})

tab4:Text('UI')

tab4:Checkbox({
	Title    = "Panic Key";
	Callback = function(value)

	end;
})

tab4:Text('Automatically destroys the gui, and disables all features.')
local Args = {"A", "B", "GP", "EN"}

local function ScanTable(Table)
	for i, v in ipairs(Args) do
		if (not rawget(Table, v)) then
			return false
		end
	end
	return true
end

local Functions

for d, v in ipairs(getgc(true)) do
	if typeof(v) == "table" and ScanTable(v) then
		Functions = v
		break
	end
end

hookfunction(Functions.A, function() end)
hookfunction(Functions.B, function() end)



local ScreenGui = Instance.new("ScreenGui")
local TextLabel = Instance.new("TextLabel")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false

TextLabel.Parent = ScreenGui
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 2.000
TextLabel.Position = UDim2.new(-0.0118684275, 0, 0, 0)
TextLabel.Size = UDim2.new(0, 200, 0, 50)
TextLabel.Font = Enum.Font.SourceSansSemibold
TextLabel.Text = "Kinetic Lite - Test 1.23"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextSize = 14.000
TextLabel.TextStrokeTransparency = 0.980


	TextLabel.TextColor3 = Color3.fromRGB(255,255,255)

Notify('Kinetic Lite Loaded')


return library

